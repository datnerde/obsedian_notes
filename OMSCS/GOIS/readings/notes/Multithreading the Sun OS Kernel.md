# Abstract
----
* Using threads makes the kernel fully preemptible and capable of real-time response
# Introduction
----
- support multiprocessors in SunOS; go further than just adding locks
- support more than one thread of control within a user process
- capable of low latency / user-level multithreading
# Overview of the Kernel Architecture
----
- Kernel Threads are lightweight
	- small data structure and stack
	- switching does not require changing virtual memory address
	- fully preemptible
- Kernel Threads are used to:
	- provide asynchronous kernel activity
		- remove diversions in the idle loop and trap code
		- replaces them with independently scheduled threads
	- interrupts are also handled by kernel threads
	- support of multiple kernel-supported threads of control 
		- LWPs = lightweight processes
		- while all LWPs have a kernel thread, not all kernel threads have an LWP
	- user-level library
		- uses LWPs to implement user-level threads
		- scheduled at user-level and switched by the library to any of the LWPs belonging to the process
		- bound to a particular LWP
		- user-level threads can be switched between without entering the kernel
		- allows a user process to have thousands of threads without overwhelming kernel resources
# Data Structures
---
- Traditionally, `user` and `proc` structures contained all kernal data for a given process
- The new kernel separated the data into data associated with each LWP and its kernel thread
- Per-process data is contained in the `proc` structure and contains a list of:
    - kernel threads associated with the process
    - pointer to the process address space
    - user credentials
    - list of signal handlers
- The LWP structure contains:
    - PCB (Process Control Block)
        - processor registers
        - system call arguments
        - signal handling masks
        - resource usage info
        - profiling pointers
    - Pointers to the kernel thread and process structures
- The Kernel Thread structure contains:
    - kernel registers
    - scheduling class
    - dispatch queue links
    - pointers to the stack and associated LWP, process, and CPU structures
- Per-processor data is kept in the `cpu` structure
    - contains pointers to the currently executing thread, idle thread, dispatching and interrupt handling information
- To speed access to the thread, LWP, process, and CPU structures, there is a global register (%g7) that points to the current thread structure
# Kernel Thread Scheduling
-----
- A scheduling class determines the relative priority of processes within a class and converts it to a global priority
    - The scheduling class and dispatcher operate on threads instead of processes
    - Three Scheduling classes in SPARC
        - system
        - time-share
        - real-time (Fixed Priority)
- The dispatcher choose the thread with the greatest global priority
    - If there are two with the same priority, they are dispatched in round robin order
- By making the kernel preemptible, the real-time class and interrupt threads are better supported
# System Threads
---
- Can be created for short and long term activities
- Scheduled like any thread but belong to system scheduling class
- No need for LWP structure so the thread and stack are allocated together in a non-swappable area
- The segment driver, `seg_kp` handles stack allocations
    - Also handles virtual memory allocations for the kernel and provides "red zones" to protect stack overflows
# Synchronization Architecture
---
- Kernel uses same synchronization objects as the user-level libraries
    - Mutex (Mutual Exclusion Locks)
    - Condition variables
    - Semaphores
    - multiple readers
    - single writer (reader/writer) locks
- The synchronization object is specified when it is initialized
- Synchronization options take a pointer to the object as an argument
- Most objects allow for collecting statistics
- Most synchronization primitives prevent thread from getting past the primitive until some condition is satisfied
    - Sleep
    - Spin
    - Other
- By default, kernel thread synchronization primitives can _potentially_ sleep
- Some synchronization primitives are "_strictly bracketing_" which means the thread that locks a mutex, must be the one that unlocks it
- Some synchronization primitives are intended for use where they may block for long or indeterminant periods
    - `cv_wait_sig()`
    - `sema_p_sig()`
        - These allow blocking to be interrupted by reception of a signal
        - Once a signal is received, the caller must release any resources and return
# Mutual Exclusion Lock Implementation
---
- Mutexes are the most commonly used primitive
    - Usually held for short intervals
        - So don't wait for Disk I/O while using this
    - Not recursive (cannot call `mutex_enter()` once already entered)
    - Thread that holds a mutex must release the mutex
        - These rules help to avoid deadlocks
- If `mutex_enter` cannot set an already set lock, the blocking action taken will depend on the mutex type that was passed to `mutex_init()`
    - The default blocking policy is called _adaptive_
        - type `MUTEX_DEFAULT`
        - spins while the owner of the lock remains running
            - Done by polling the owner's status
            - If the owner stops running, the caller stops spinning and sleeps
            - Gives fast response and low overhead
- Spin mutexes are another type (`MUTEX_SPIN`)
    - Rarely used as adaptive mutex is more efficient
- Device drivers have their own mutex type, `MUTEX_DRIVER`
- `mutex_enter()` for adaptive mutexes
    - non-adaptive mutexes use a separate primitive lock field in the mutex data structure
        - So, it can always try to apply an adaptive lock first, and if that fails, consider the mutex may be another type
# Turnstiles vs Queues in Synchronization Objects
---
- Each object needs way to find threads that are suspended and waiting for that object
- To reduce storage cost of synchronization objects, the queue header is not in the object, but rather preallocated.
    - Therefore the header information is stored as two bytes pointing to a turnstie structure containing the sleep queue header and priority inheritnace information
- Alternatively, the sleep queue can be sleected using a hash function on the address of the synchronzation object
    - `sleep()` uses this approach in a traditional kernel
- That said, the turnstile approach is favored for more predictable real-time behaviour since they are never shared by other locks
# Interrupts as Threads
---
- Various implementations have various synchronization primitives
- For mutexes, spin primitives must hold the interrupt priority high enough to prevent interrupt handlers from using the synchronization object while it is locked (causing a deadlock)
    - The interrupt level must be raised before the lock is acquired and lowered after the lock is released
- Drawbacks of this Approach
    - Raising and lowering is an expensive operation
    - Many subsystems are interdependent and the mutexes must protect themselves at a fairly high interrupt level
    - Interrupt handlers must avoid use of kernel functions that can potentially sleep, even for short periods
- To avoid the above drawbacks
    - interrupts are asynchronously created and dispatched high-priority threads
        - This allows them to sleep and use the standard synchronization primitives
- Putting threads to sleep must be done in software
    - For this reason, this section of code is bounded and cannot be interrupted
- Traditional UNIX kernels protect the dispatcher by locking out interrupts
- But the restructured kernel has a level above which interrupts are handled more like firmware.
    - If the thread level is set to max, then all interrupts are locked out during dispatching.
# Implementing Interrupts as Threads
---
- Previous SunOS versions worked like UNIX - once an interrupt occurs the interrupted process is _pinned_ until the interrupt returns
- In SunOS 5.0, interrupts behave like asynchronous threads
    - Interrupt threads are preallocated and partly initialized
    - When an interrupt occurs, the minimum amount of work is done to move on to the stack of an interrupt thread and set it as the current thread
    - At this point, the interrupt thread is not a full-fledged thread (can't be descheduled) and the interrupted thread is _pinned_ until the interrupt thread returns or blocks
    - When the interrupt returns, the interrupted thread state is restored
- Interrupts may nest - an interrupt thread my be interrupted!
- If an interrupt thread blocks on a synchronization variable (mutex or condition), it saves state (_passivates_) and becomes a full-fledged thread, capable of being run by the CPU, and then returns to the pinned thread.
- While interrupt threads are in progress its interrupt level and all lower priority interrupts are blocked
    - If the thread blocks, normal interrupts must be disabled in case the interrupt handler is not reenterable or is doing high-priority processing
    - While blocked, the interrupt thread is bound to a particular processor (the one it stared on)
        - A flag is set in the CPU to indicate an interrupt at that level has blocked and the minimum interrupt level is noted
        - When the interrupt level changes, the base interrupt level is checked and the interrupt priority level is not allowed below that
- When `release_interrupt()` is called, it saves the state of the pinned thread and clears the interrupt indication which allows the CPU to lower the interrupt priority level
- Alternatively, we can use _bounded first-level interrupt handlers_ to capture device state, whatever that means....
    - But this requires device drivers to be restructured and a full context switch
## Interrupt Thread Cost
- Taking an interrupt costs 40 SPARC instructions
- Savings in mutex enter/exit is 12 instructions
    - But mutexes are much more frequent
- There is also a memory cost
    - An interrupt thread is preallocated for each potentially active interrupt level below the thread level
    - An additional interrupt thread is preallocated for the clock (one per system)
    - Each thread requires a stack and data structure of about 8KB so the memory cost can add up
    - But since it is unlikely all interrupt levels will be active, we can have a smaller pool of threads and block all interrupts below the thread level when the pool is empty
        - Note: The Sun SPARC implementation has 9 levels.
## Clock Interrupt
