# Abstract
----
* Using threads makes the kernel fully preemptible and capable of real-time response
# Introduction
----
- support multiprocessors in SunOS; go further than just adding locks
- support more than one thread of control within a user process
- capable of low latency / user-level multithreading
# Overview of the Kernel Architecture
----
- Kernel Threads are lightweight
	- small data structure and stack
	- switching does not require changing virtual memory address
	- fully preemptible
- Kernel Threads are used to:
	- provide asynchronous kernel activity
		- remove diversions in the idle loop and trap code
		- replaces them with independently scheduled threads
	- interrupts are also handled by kernel threads
	- support of multiple kernel-supported threads of control 
		- LWPs = lightweight processes
		- while all LWPs have a kernel thread, not all kernel threads have an LWP
	- user-level library
		- uses LWPs to implement user-level threads
		- scheduled at user-level and switched by the library to any of the LWPs belonging to the process
		- bound to a particular LWP
		- user-level threads can be switched between without entering the kernel
		- allows a user process to have thousands of threads without overwhelming kernel resources
# Data Structures
---
- Traditionally, `user` and `proc` structures contained all kernal data for a given process
- The new kernel separated the data into data associated with each LWP and its kernel thread
- Per-process data is contained in the `proc` structure and contains a list of:
    - kernel threads associated with the process
    - pointer to the process address space
    - user credentials
    - list of signal handlers
- The LWP structure contains:
    - PCB (Process Control Block)
        - processor registers
        - system call arguments
        - signal handling masks
        - resource usage info
        - profiling pointers
    - Pointers to the kernel thread and process structures
- The Kernel Thread structure contains:
    - kernel registers
    - scheduling class
    - dispatch queue links
    - pointers to the stack and associated LWP, process, and CPU structures
- Per-processor data is kept in the `cpu` structure
    - contains pointers to the currently executing thread, idle thread, dispatching and interrupt handling information
- To speed access to the thread, LWP, process, and CPU structures, there is a global register (%g7) that points to the current thread structure
# Kernel Thread Scheduling
-----
- A scheduling class determines the relative priority of processes within a class and converts it to a global priority
    - The scheduling class and dispatcher operate on threads instead of processes
    - Three Scheduling classes in SPARC
        - system
        - time-share
        - real-time (Fixed Priority)
- The dispatcher choose the thread with the greatest global priority
    - If there are two with the same priority, they are dispatched in round robin order
- By making the kernel preemptible, the real-time class and interrupt threads are better supported
# System Threads
---
- Can be created for short and long term activities
- Scheduled like any thread but belong to system scheduling class
- No need for LWP structure so the thread and stack are allocated together in a non-swappable area
- The segment driver, `seg_kp` handles stack allocations
    - Also handles virtual memory allocations for the kernel and provides "red zones" to protect stack overflows
# Synchronization Architecture
---
- Kernel uses same synchronization objects as the user-level libraries
    - Mutex (Mutual Exclusion Locks)
    - Condition variables
    - Semaphores
    - multiple readers
    - single writer (reader/writer) locks
- The synchronization object is specified when it is initialized
- Synchronization options take a pointer to the object as an argument
- Most objects allow for collecting statistics
- Most synchronization primitives prevent thread from getting past the primitive until some condition is satisfied
    - Sleep
    - Spin
    - Other
- By default, kernel thread synchronization primitives can _potentially_ sleep
- Some synchronization primitives are "_strictly bracketing_" which means the thread that locks a mutex, must be the one that unlocks it
- Some synchronization primitives are intended for use where they may block for long or indeterminant periods
    - `cv_wait_sig()`
    - `sema_p_sig()`
        - These allow blocking to be interrupted by reception of a signal
        - Once a signal is received, the caller must release any resources and return
# Mutual Exclusion Lock Implementation
---
- Mutexes are the most commonly used primitive
    - Usually held for short intervals
        - So don't wait for Disk I/O while using this
    - Not recursive (cannot call `mutex_enter()` once already entered)
    - Thread that holds a mutex must release the mutex
        - These rules help to avoid deadlocks
- If `mutex_enter` cannot set an already set lock, the blocking action taken will depend on the mutex type that was passed to `mutex_init()`
    - The default blocking policy is called _adaptive_
        - type `MUTEX_DEFAULT`
        - spins while the owner of the lock remains running
            - Done by polling the owner's status
            - If the owner stops running, the caller stops spinning and sleeps
            - Gives fast response and low overhead
- Spin mutexes are another type (`MUTEX_SPIN`)
    - Rarely used as adaptive mutex is more efficient
- Device drivers have their own mutex type, `MUTEX_DRIVER`
- `mutex_enter()` for adaptive mutexes
    - non-adaptive mutexes use a separate primitive lock field in the mutex data structure
        - So, it can always try to apply an adaptive lock first, and if that fails, consider the mutex may be another type
# Turnstiles vs Queues in Synchronization Objects
---
- Each object needs way to find threads that are suspended and waiting for that object
- To reduce storage cost of synchronization objects, the queue header is not in the object, but rather preallocated.
    - Therefore the header information is stored as two bytes pointing to a turnstie structure containing the sleep queue header and priority inheritnace information
- Alternatively, the sleep queue can be sleected using a hash function on the address of the synchronzation object
    - `sleep()` uses this approach in a traditional kernel
- That said, the turnstile approach is favored for more predictable real-time behaviour since they are never shared by other locks
# Interrupts as Threads
---
