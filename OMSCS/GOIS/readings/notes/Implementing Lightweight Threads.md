# Introduction
---
- Threads Library Implementation
    - Lightweight but allow fully concurrent access to system resources
    - User threads multiplex on a pool of kernel-supported threads
    - Includes threads library and a modified kernel to support multiple threads in a single UNIX process
# Threads Model
---
- Traditionally, UNIX processes had a single thread
- SunOS Multi-thread Architecture allowed for more than one thread
- Threads are viewed as execution resources that can be applied to solving the problem at hand
- Threads share process instructions and most of its data
- A change in shared data can be seen by the other threads in the process
    - Ex. One thread opens a file, another can read from it
- Synchronization Facilities
    - Mutex Locks
    - Condition Variables
    - Semaphores
    - Multiple Readers / Single Writers locks
- Synchronization variables are allocated in ordinary memory
- Threads in different processes can synchronize via synchronization variables in shared memory or mapped files
    - These variables must be marked as being process-shared when they are initialized
    - They may have different variants with different blocking behavior
- Each thread has its own program counter (PC) and stack to keep track of local variables and return addresses
- Each thread can make arbitrary system calls and interact with processes
- NOTE: If one thread calls `exit()` all threads are destroyed
- Each thread has its own signal mask
    - This allows blocking asynchronously generated signals while accessing a state modified by a signal handler
    - Synchronously generate signals such as `SIGSEGV` are sent to the thread that caused them
    - Externally generated signals are sent to one of the threads that has it unmasked
        - If all threads mask a signal, it is set to pending until a thread unmasks it
        - Signals can also be send to particular threads in the same process
        - The number of signals recieved by the process is less than or equal to the number sent
- All threads within a process share the set of signal handlers
    - If the handler is set to `SIG_IGN` any received signals are discarded
    - If the handler is set to `SIG_DFL` the default action (ex. stop, continue, exit) applies to the process as a whole
- Processes can fork in one of two ways
    - The first clones the entire process and all of its threads
    - The second only reproduces the calling thread in the new process
        - This is useful when the process is going to call `exec()`
# Threads Library Architecture
---
- Threads are the programmer's interface for multi-threading
- LWP (LightWeight Processes) can be thought of as a virtual CPU
- Each LWP is separately dispatched by the kernel onto the available CPUs according to scheduling class and priority
- The threads library schedules threads on a pool of LWPs in the same way the kernel schedules LWPs on a pool of processors
- Threads are simply data structures and stacks maintained by the library
- The thread library can start and stop threads without involving the kernel
    - Also, create, destroy, block, activate etc without the OS getting involved
- LWPs are more expensive than threads as each one uses kernel resources
- Note: only a few threads need to be active at the same instant
- Some threads must be visible to the system, for example, when a real-time response in needed such as for a mouse tracking thread
    - This is accomplished by binding the thread to be permanently bound to an LWP
- Most programmers use threads and don't worry about LWPs
# LWP interfaces
---
- Similar to threads
	- Share most process resources
	- Has private set of registers and a signal mask
	- Have attributes unavailable to threads
	    - Kernel-supported scheduling class, virtual time timers, alternate signal stack, and profiling buffer
- `_lwp_create()` creates another LWP within the process
- `_lwp_makecontext()` creates a machine context that emulates the standard calling sequence to a function
    - This context can then be passed to `_lwp_create()`
    - This gives some measure of machine independence
- LWP synchronization interfaces use mutex locks, condition variables, and counting semaphores
- These routines only enter the kernel if necessary
- LWP synchronization variables are placed in memory by the application
    - if placed in shared memory or mapped files, they are accessible to other processes
    - Using memory mapped files allows synchronization variables and shared data to be preserved in a file
        - the application can then be restarted and resume execution without initialization
- When a LWP synchronization primitive causes the calling LWP to block, it is suspended on a kernel-supported sleep queue associated with the offset in the mapped file or shared memory segment
    - This allows LWPs in different processes to synchronize despite having different virtual memory
- `_lwp_getprivate()` and `_lwp_setprivate()` provide one pointer's worth of storage that is usually used to point to the thread's data structure (on SPARC this is register `%g7`)
- Alternatively, we could have a private memory page for each LWP which requires more kernel effort and more memory
    - But, this is useful on register-constrained machines or machines where registers are not reserved to the system
- Two additional signals:
    - `SIGLWP` Used as in inter-LWP signal mechanism using the `_lwp_kill()` interface
    - `SIGWAITING` Generated by the kernel when all LWPs in a process have been blocked in indefinite waits
        - Used by threads package to ensure processes don't deadlock indefinitely
# Threads Library Implementation
---
- Thread structure:
    - thread ID
    - area to save execution context
    - thread signal mask
    - thread priority
    - pointer to the thread stack
- Thread stack storage is either automatically allocated by the library or passed in by the application on thread creation
- Library allocated stacks are obtained by mapping pages in memory
    - The page following the stack is invalid to protect from overruns (red zone)
- When a thread is created a thread ID is assigned
    - The ID is an index in a table of pointers to thread structures
    - provide meaningful errors
# Thread-local Storage
---


